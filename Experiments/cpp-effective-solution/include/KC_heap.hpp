/*
В процессе поиска алгоритмом A* придётся очень часто создавать и удалять вершины Vertex и SearchNode. Обычно это
делается в области памяти, которая в C/C++ называется "куча" (англ. heap), с помощью оператора new (он возвращает
указатель на созданный в памяти экземпляр класса):
    Vertex* v = new Vertex();
После того, как вершина v перестанет быть нужна, её можно удалить, освободив занимаемую её память. Это делается оператором delete:
    delete v;

Основная сложность в том, что таких new/delete в процессе поиска будет огромное количество. А постоянное обращение к куче
с запросом выделения/освобождения памяти - сильно тормозит работу программы. Гораздо эффективнее сделать только один запрос к куче,
но выделив сразу много-много вершин Vertex. А уже затем, при необходимости, из этого набора вынимать (аналог new) новую вершину
или класть в него обратно (аналог delete), если она перестала быть нужна. Именно такая идея реализуется в данном файле.

Данный файл описывает реализацию структуры MyHEAP, которая будет играть роль области памяти "куча": в ней заранее будут выделены
из памяти большие наборы Vertex и SearchNode. Эти наборы будут храниться в виде вектора (обычный std::vector из стандартной 
библиотеки C++). Когда в коде потребуется создать новую вершину Vertex, вместо операции new (которая бы вернула указатель
на новосозданную вершину в памяти) достаточно обратиться к MyHEAP, которая вернёт индекс в векторе, по которому лежит
неиспользуемый экземпляр Vertex - и далее код с этим экземпляром будет работать. Когда же экземпляр Vertex перестанет
быть нужен, код вместо операции delete просто обратится к MyHEAP и вернёт ей этот индекс (MyHEAP у себя запомнит, что
вершина по этому индексу снова неиспользуема и может быть выделена при новом запросе). В случае, если размер векторов
в MyHEAP станет недостаточен (в коде потребуется использовать больше вершин), то она просто сделает resize этих векторов,
получив больше памяти (это сделает обращение к памяти, однако такие resize будут происходить гораздо реже, чем
появление/удаление вершин, поэтому работать всё будет быстро).
*/

#pragma once

#include <iostream>
#include <vector>

#define NULL_Node ptrSearchNode(-1)  // формально определим два экземпляра, которые будут указывать, что такого ptr... не существует 
#define NULL_Vertex ptrVertex(-1)  //                  (аналогично NULL у указателей)

struct SearchNode;  // объявляем компилятору, что эти типы можно использовать, они будут записаны в коде в другом файле
struct Vertex;

using namespace std;




struct ptrVertex {
    /*
    Эта структура описывает то, что возвращает MyHEAP при запросе выделения новой вершины Vertex. Фактически 
    это будет просто индекс внутри вектора из MyHEAP, по которому лежит выделенная Vertex. Однако данная структура
    для удобства будет поддерживать операцию "->", которая будет работать так же, как в случае с указателем Vertex*
    (Мотивация следующая: Обычно для создания новой вершины используется "new Vertex()", которая возвращает указатель
    "Vertex* v", по которому можно обращаться к полям Vertex через "->" - например, "v->i", "v->theta" и тд. Но теперь
    выделение будет из MyHEAP и возвращаться из неё будет "ptrVertex v" (которая фактически будет индексом внутри вектора,
    в котором хранятся все Vertex) - и с ним хочется обращаться как раньше с указателем и писать "v->i", "v->theta" и тд.
    Для этого как раз нужно определить operator->, который по экземпляру ptrVertex будет возвращать указатель Vertex* на
    выделенную вершину в векторе - и тогда с ptrVertex можно работать как с указателем Vertex* и писать "->" для доступа к полям) 
    */

    int ind;  // индекс экземпляра Vertex внутри вектора vertexs из MyHEAP

    ptrVertex();  // конструкторы класса
    ptrVertex(int i);
    Vertex* operator->() const;  // определим оператор "->"
    bool operator==(ptrVertex other);  // определим оператор проверки на равенство
};


struct ptrSearchNode {
    /*
    Здесь полностью аналогично, что и с Vertex.
    */

    int ind;

    ptrSearchNode();
    ptrSearchNode(int i);
    SearchNode* operator->() const;
    bool operator==(ptrSearchNode other);
};


struct MyHEAP {
    /*
    Данная структура хранит собственную версию памяти "куча".
    */

    vector <Vertex> vertexs;  // вектор, где будут храниться все используемые экземпляры Vertex (они будут заранее выделяться из памяти)
    vector <SearchNode> nodes;  // аналогично вектор из SearchNode

    vector <int> index_free_vertexs;  // в этих двух векторах будут храниться индексы (в vertexs и nodes соответственно) неиспользуемых   
    vector <int> index_free_nodes;   //              экземпляров, которые можно выдать при запросе 

    int N;  // всего имеющихся в памяти Vertex и SearchNode (= размер vertexs и nodes)

    MyHEAP();
    void resize();  // функция, которая добавляет больше экземпляров (увеличивает vertexs и nodes), если неиспользуемые закончились
    int get_ind(vector <int> &index);

    ptrVertex new_Vertex(int i, int j, int theta);  // следующие функции выделяют новый экземпляр Vertex в виде индекса в векторе vertexs (который обёрнут в структуру ptrVeretx)
    ptrVertex new_Vertex(int i, int j, int type, size_t info);
    ptrSearchNode new_SearchNode(ptrVertex v);
    
    void delete_Vertex(ptrVertex state);  // функции, удаляющие экземпляры, которые стали ненужными (при этом индекс просто возвращается в index_free_...)
    void delete_SearchNode(ptrSearchNode node);
};
