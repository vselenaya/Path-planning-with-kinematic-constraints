"""
Данный код реализует многомерный метод Ньютона для генерации (оптимизации, подбора параметров) траектории.

В общем виде работает это следующим образом: заводится экземпляр класса ShortTrajectory, в котором фиксируются
начальное start и целевое goal состояния, между которыми генерируем траекторию. При зафиксированных этих состояниях
траектория определяется ровно тремя параметрами k1, k2, log_length второй параметризации (так как kf уже фиксирован
в goal), которые нужно подобрать. Для их подбора заводится функция get_residual, которая возвращает три числовых значения
(трехмерный вектор) - разность между компонентами x,y,theta целевого goal и текущего (при текущих k1, k2, log_length)
финального состояния final_state траектории. Эти числа хочется занулить (чем ближе они к нулю, тем более траектория идёт
в goal). Получается, что есть три параметра k1, k2, log_length, которыми определяются три значения функции get_residual,
которые хочется занулить (всё это при фиксированных start и goal). Этим и занимается многомерный метод Ньютона, 
задача которого подобрать значения k1, k2, log_length, чтобы get_residual было как моно ближе к 0.

Таким образом, можно генерировать траекторию между фиксированными start и goal.
"""

import numpy as np

import sys
sys.path.append("../common/")  # это позволяет делать import файла в параллельной папке common
from KC_structs import *
from KC_graphics import *



def get_residual(traj: ShortTrajectory) -> np.ndarray:
    """
    Функция, которая вычисляет невязку: покомпонентную разность между целевым состоянием goal
    и текущим концом траектории final_state. Генерация траектории заключается в попытке занулить эту функцию.
    
        traj: экземпляр ShortTrajectory, короткая траектория (параметры k1, k2, log_length которой подбираются при генерации).
    """
    
    final = traj.final_state()  # текущее финальное состояние
    return np.array([traj.goal.x - final.x,
                     traj.goal.y - final.y,
                     traj.goal.theta - final.theta])   # покомпонентная разница с целевым состоянием goal
                                                       # заметим, что учитываются только x,y,theta, так как кривизна kf в финальном состоянии
                                                       # равна кривизне в goal (так как kf является четвёртым параметром второй параметризации ->
                                                       # -> он при фиксированном goal сразу определяется, даже подбирать не нужно -> удобно!)



def calc_Jacobian_matrix(traj: ShortTrajectory, params: np.ndarray, dk: float = 0.001, dS: float = 0.001) -> np.ndarray:
    """
    Функция вычисляет матрицу Якоби (3 на 3) для функции get_residual, рассматриваемой как функции от параметров 
    короткой траектории (во второй параметризации). Её можно так рассматривать, ведь параметры (при фиксированном начальном состоянии
    и фиксированной конечной кривизне goal.k) однозначно задают траекторию, а по траектории однозначно считается функция невязки.
    Функция get_residual трёхмерная (возвращаемый ею вектор невязки длину 3 имеет) и количество параметров короткой
    траектории (во второй параметризации при фиксированном целевом состоянии) тоже три (k1, k2, log_length), поэтому матрица Якоби будет
    иметь размер 3 на 3 и состоять из частных производных компонентов функции невязки по параметрам траектории. Частные
    производные считаются численно, приблизительно.
    
        traj: траектория между фиксированными состояниями start, goal,
        params: текущие параметры траектории k1, k2, log_length (в этой точке считается матрица),
        dk, dS: небольшое приращение параметров, чтобы численно подсчитать производную.
        
    Замечание: таким образом, start и params однозначно фиксируют текущую траекторию -> после чего вычисляется матрица
    Якоби функции невязки (всё это при фиксированном goal) - вычисление происходит в точке params.
    """
    
    k1, k2, log_length = params  # текущие параметры
    traj = ShortTrajectory(traj.start, traj.goal)  # создаём копию (в смысле, те же состояния) траектории, чтобы не портить имеющуюся
    
    dF_p = get_residual(traj.set_curve_params(k1+dk, k2, log_length))  # считаем невязку при сдвинутом параметре k1
    dF_m = get_residual(traj.set_curve_params(k1-dk, k2, log_length))
    grad_k1 = (dF_p - dF_m) / (2 * dk)  # поделив разницу значений функции невязки на величину приращения параметра,
                                        # получаем приблизительное значение частных производных компонентов get_residual по k1

    dF_p = get_residual(traj.set_curve_params(k1, k2+dk, log_length))
    dF_m = get_residual(traj.set_curve_params(k1, k2-dk, log_length))
    grad_k2 = (dF_p - dF_m) / (2 * dk)  # приблизительное значение частных производных компонентов get_residual по k2

    dF_p = get_residual(traj.set_curve_params(k1, k2, log_length+dS))
    dF_m = get_residual(traj.set_curve_params(k1, k2, log_length-dS))
    grad_S = (dF_p - dF_m) / (2 * dS)  # по log_length

    return np.hstack((grad_k1.reshape(-1, 1), grad_k2.reshape(-1, 1), grad_S.reshape(-1, 1)))  # собираем все частные производные в матрицу Якоби 



def optimization_Newton(start: State, goal: State, iters: int = 2000, eps: float = 1e-2, lr: float = 0.03, show_animation: bool = True) -> ShortTrajectory:
    """
    Функция многомерного метода Ньютона, которая оптимизирует параметры траектории -> генерирует траекторию.

        start, goal: состояния, между которыми хотим построить короткую допустимую траекторию,
        iters: число итераций метода Ньютона (число N в тексте диплома),
        eps: норма функции невязки, при достижении которой считаем, что траектория уже идёт достаточно точно
                идёт в целевое состояние и останавливаем алгоритм,
        lr: шаг, с которым происходит оптимизация (коэффициент \alpha в тексте диплома),
        show_animation: показывать ли процесс оптимизации траектории.
    """
    
    traj =  ShortTrajectory(start, goal)  # фиксируем траекторию между двумя состояниями
    params = np.array([0.0, 0.0, 0.0])  # начальные параметры траектории (во второй параметризации)

    for i in range(iters):
        curr_diff = get_residual(traj.set_curve_params(*params))  # вычисляем текущую невязку: для этого устанавливаем текущие параметры в traj
        J = calc_Jacobian_matrix(traj, params)  # вычисляем матрицу Якоби в текущих параметрах params
        params -= lr * np.linalg.inv(J) @ curr_diff  # обновляем параметры многомерным методом Ньютона ->
                                                     # -> стремимся занулить невязку curr_diff

        if np.sum(curr_diff ** 2) ** 0.5 <= eps:  # если норма невязки достаточно мала, можно останавливать поиск
            break

        if show_animation and (i % 20 == 0):  # каждые 20 итераций перерисовываем траекторию
            redraw_trajectory(traj)
    
    else:
        print("Невозможно найти траекторию! Метод Ньютона не сошёлся!")
        return None

    return traj.set_curve_params(*params)  # возвращаем найденную траекторию (с найденными параметрами)
