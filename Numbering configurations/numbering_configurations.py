"""
Здесь описана полностью самостоятельная программа, которая по файлу с примитивами (control set) генерирует
файл с описанием нумерации конфигураций (типами ячеек), соседями, информацией для склеивания вершин.
Это самостоятельный код, не предназначен для импортирования
"""
if __name__ != "__main__": raise ImportError("Этот модуль не является импортируемым!")



from typing import List, Tuple, Dict, Generator
from typing_extensions import Self

import sys
sys.path.append("../common/")  # это позволяет делать import файла в параллельной папке common
sys.path.append("./common")  # это нужно, если запуск производится из над-директории (тогда относительно неё папка common будет по пути ./common)
from KC_structs import *
from KC_searching import *




def step_shift(prim: Primitive, k: int) -> Tuple[int, int]:
    """
    Данная функция получает шаговый сдвиг вдоль примитива prim из его клетки коллизионного следа степени k.
    
        prim: примитив,
        k: степень в примитиве (номер клетки коллизионного следа). 
    """

    assert 0 <= k < prim.U-1, "Для шагового сдвига необходима НЕ максимальная степень"
    curr_ij = (prim.collision_in_i[k], prim.collision_in_j[k])  # клетка степени k
    next_ij = (prim.collision_in_i[k+1], prim.collision_in_j[k+1])  # следующая (в порядке похождения prim) клетка степени k+1 
    delta_ij = (next_ij[0] - curr_ij[0], next_ij[1] - curr_ij[1])
    assert delta_ij in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)], "Невозможный шаговый сдвиг!"  # шаговых сдвигов может быть 8 вариантов
    
    return delta_ij




class PrimsConfiguration:
    """
    Этот класс будет хранить конфигурацию примитивов.
    """
    
    
    def __init__(self, control_set: ControlSet) -> None:
        """
        Инициализация. Так как конфигурация примитивов зависит от самих примитивов, то
        при инициализации запоминаем используемый Control set.
        """
        
        self.control_set = control_set
        self.config_list = set()  # в этом списке (на самом деле множестве) будет храниться сама конфигурация - набор пар из примитива и степени в нём
                                  # (мы используем множество, так как порядок пар нас не интересует... боле того одинаковых пар (в смысле из одинаковых примитивов и их равных степеней)
                                  # мы считаем, что быть не может... во всяком случае в достижимых конфигурациях и адекватном (где нет повторяющихся примитивов) control set это верно)


    def add_element(self, pair: Tuple[Primitive, int]) -> Self:
        """
        Эта функция пополняет конфигурацию очередной парой из примитива и степени в нём.
        
            pair: пара из примитива и степени в нём, которая добавляется к конфигурации.
        """
        
        prim, power = pair
        assert 0 <= power < prim.U, "Некорректная степень в примитиве!"  # степень в примитиве от 0 до U-1 включительно, так как это номер клетки коллизионного следа
        self.config_list.add(pair)  # заметим, что делать вставку в set мы можем, так как у класса Primitive определён __hash__ и __eq__, а у int они по умолчанию есть (а проверка tuple на равенство и хеширование производятся покомпонентно)
        
        return self
    
    
    def make_valid(self) -> Self:
        """
        Эта функция исправляет (изменят способ представления, записи в памяти) конфигурацию, делая ячейку, в которой она находится,
        допустимой. Смысл исправления в том, чтобы все степени всех примитивов были НЕ максимальные. Для этого каждую пару из примитива
        и максимальной степени (то есть примитив заканчивается) заменяем на набор начинающихся (с 0-ой степенью) примитивов, 
        выходящих под тем дискретным углом, под которым кончился заменяемый. Эта замена полностью эквивалентна (смысл ячейки с 
        конфигурацией не меняется), поэтому меняется лишь запись (конкретный список пар) конфигурации.
        """ 
        
        new_list = set()  # новый список пар (его мы считаем записью конфигурации)
        
        for (prim, power) in self.config_list:  # перебираем пары примитива и степени
            
            if power < prim.U - 1:  # если степень не максимальная, то просто добавляем пару в новый список
                new_list.add((prim, power))
                
            else:  # если же степень максимальна, то вместо этой пары добавляем набор начинающихся примитивов
                for new_prim in self.control_set.get_prims_heading(prim.goal.theta):  # перебираем примитивы, начинающиеся под тем углом, под которым закончился текущий
                    new_list.add((new_prim, 0))  # добавляем
                    
        self.config_list = new_list  # обновляем список
        return self            
            
        
    def __eq__ (self, other: 'PrimsConfiguration') -> bool:
        """
        Функция, которая проверяет на равенство две конфигурации. Эта и следующая (хеширование) функции требуются, чтобы
        использовать конфигурацию как ключ в словаре (так как ключ словаря хэшируется (для этого нужен хеш), а в случае
        совпадения хешей Питон должен проверить два ключа на равенство).
        
        Так как смысл конфигурации в том, чтобы помнить проходящие в данной клетке примитивы и как именно они проходят (то есть
        какая степень этой клетки в каждом примитиве), то нас интересует в ней только сами пары (примитив, степень), а их порядок
        не важен (поэтому храним их в set, где вообще нет порядка). Таким образом, равными считаем конфигурации, в которых
        наборы (неупорядоченные) пар совпадают (формально можно сказать так: CONF1 = CONF2, если любая пара (prim,k) из CONF1
        также присутствует в CONF2 и наоборот: любая (prim,k) из CONF2 есть и в CONF1).
        """
        
        self.make_valid()  # приводим конфигурации к допустимому виду (чтобы зафиксировать конкретный способ записи, чтобы в качестве self и other
        other.make_valid()          # не могла быть одна и та же конфигурация, отличающиеся только из-за способа записи: одна допустимая, другая нет)
        return (self.config_list == other.config_list)  # равными считаем конфигурации, которые совпадают как множества (=неупорядоченный список)
                                                        # пар (то есть в которых одинаковые примитивы и одинаковые их степени независимо от порядка, в котором они идут)
    
    
    def __hash__ (self) -> int:
        """
        Функция, возвращающая хеш конфигурации. У равных конфигураций хеш обязан совпадать.
        """
        
        self.make_valid()
        return hash(frozenset(self.config_list))  # превращаем конфигурацию во frozenset (это неизменяемый и неупорядоченный набор элементов), после чего хешируем
                                                  # так как frozenset неупорядочен, то его хеш не зависит от порядка пар в конфигурации -> у равных как множество конфигураций будет одинаковый хеш
        
    
    def __iter__(self) -> Generator[Tuple[Primitive, int], None, None]: 
        """
        Делаем конфигурацию итерируемой (чтобы можно было писать for (prim,k) in конфигурация). Для этого просто описываем, что
        итерирование по конфигурации - это итерирование по списку пар.
        """
        
        for each in self.config_list:
            yield each




def StartConf(l: int, control_set: ControlSet) -> PrimsConfiguration:
    """
    Данная функция получает конфигурацию начальной ячейки. Это Алгоритм 8 из текста диплома.
    
        l: номер дискретного угла направления, в котором выходят примитивы в конфигурации начальной ячейки,
        control_set: набор примитивов control set, в рамках которого строится конфигурация.
    """
    
    conf = PrimsConfiguration(control_set)
    for prim in control_set.get_prims_heading(l):
        conf.add_element((prim, 0))
    return conf




class Mesh:
    """
    Класс для описания ячейки (= вершины ячейчатого графа из диплома).
    """
    
    
    def __init__(self, i: int, j: int, conf: PrimsConfiguration) -> None:
        """
        Инициализация. По определению ячейка - это клетка + конфигурация проходящей в ней примитивов.
        
            i,j: координаты клетки,
            conf: конфигурация примитивов.
            
        Замечание: В любой ячейке все примитивы рассматриваются только из control set (то есть никаких копий примитивов,
        сдвинутых параллельным переносом быть не может -> все примитивы начинаются из дискретного состояния (0,0,theta_l)). Но
        при этом смысл ячейки (i,j,conf) в том, что примитивы конфигурации conf проходят по ячейке так, что клетка (i,j) имеет
        соответствующую (указанную в конфигурации) степень в каждом примитиве prim. Можно понимать это так: если дана ячейка (i,j,conf),
        то имеется в виду, что каждая пара (prim,k) из conf кодирует примитив prim из control set, копию которого нужно параллельным
        переносом сдвинуть так, чтобы клетка (i,j) оказалось k-ой в его коллизионном следе.
        """
        
        self.i = i
        self.j = j
        self.conf = conf
        
        
    def make_valid(self) -> Self:
        """
        Данная функция переписывает ячейку так, чтобы она стала допустимой.
        """
        
        self.conf.make_valid()
        return self
    
    
    
    
def GetSuccessors(I: Mesh) -> List[Mesh]:
    """
    Функция, которая получает список соседей ячейки I. Для этого нужно сделать шаг вдоль каждого
    примитива из I. Это реализация алгоритма 9 из текста диплома.
    
        I:  ячейка, последователей которой требуется получить.
    """
    
    I.make_valid()  # сразу переписываем как допустимую (чтобы потом шаговые сдвиги вдоль примитивов существовали, так как для них требуется не максимальная степень)
    control_set = I.conf.control_set  # достаём control set, в рамках которого всё происходит
    
    i, j, conf = I.i, I.j, I.conf
    succ_confs = dict()  # словарь, который по шаговому сдвигу относительно (i,j) (= проекция I)
                         # хранит конфигурацию примитивов, получившуюся после шагов вдоль каждого
                         # примитива исходной конфигурации conf, которые приводят к такому сдвигу
    
    for (prim, k) in conf:  # перебираем пары из конфигурации
        a, b = step_shift(prim , k)  # считаем шаговый сдвиг (он существует, так как I сделали допустимой в начале функции)
        if (a, b) not in succ_confs:
            conf_new = PrimsConfiguration(control_set)
            conf_new.add_element((prim, k+1))  # пара после того, как вдоль prim из степени k сделали шаг
            succ_confs[(a, b)] = conf_new  # добавили новую конфигурацию
        else:
            succ_confs[(a, b)].add_element((prim, k+1))  # пополнили уже имеющуюся конфигурацию
    
    successors = []
    for (a, b) in succ_confs:
        conf_1 = succ_confs[(a, b)]
        i1 = i + a
        j1 = j + b
        I1 = Mesh(i1, j1, conf_1)  # очередной сосед
        successors.append(I1)
    
    return successors




class MainProcedureNumbering:
    """
    Данный класс полностью описывает процедуру нумерации конфигураций (получение типов ячеек) с помощью описанных ранее функций.
    Здесь же производиться сохранение файла полученных типов (= номерами конфигураций), их соседей. Здесь же вычисляются
    данные для склеивания вершин (типовых ячеек) в списке CLOSED для ускорения поиска.
    """
    
    
    def __init__(self, control_set: ControlSet) -> None:
        """
        Инициализация. Здесь собираем все данные, которые потребуются для дальнейшей нумерации.
        
            control_set: набор примитивов control set, конфигурации примитивов из которого нумеруются.
        """
        
        self.control_set = control_set
        self.theta_amount = control_set.theta_amount  # запоминаем количество дискретных углов - в обычном случае это 16 (такую дискретизацию брали)
        
        # словарь: по конфигурации (достижимой) храним её номер (= тип ячейки, в которой эта конфигурация находится):
        self.TYPES: Dict[PrimsConfiguration, int] = dict()   
        
        # текущий свободный номер (изначально 0 - с него стартуем), который можно выдать очередной конфигурации:
        self.NUM: int = 0  
        
        # список соседей для каждого типа t0 в виде (t,i,j) = номер типа соседа, шаговый сдвиг в него:
        # (так получается, ведь граф типов (как частный случай ячейчатого графа) инвариантен к сдвигу -> то, какие соседи
        # у типовой ячейки (i0,j0,t0) определяется только её типом t0... а сами соседи задаются их типом и сдвигом в них:
        # например, если у (i0,j0,t0) есть сосед (i1,j1,t), то у любой ячейки (a,b,t0) будет сосед (a+i,b+i,t), где i=i1-i0, j= j1-j0 ->
        # для t0 помним только t, i, j)
        self.SUCCESSORS_by_TYPE: Dict[int, List[Tuple[int, int, int]]] = dict() 
        
        # по номеру (типу) храним конфигурацию, у которой данный номер (она одна единственная, так как нумерация 
        # заключается в том, чтобы у разных конфигураций разные типы и наоборот):
        self.CONF_by_TYPE: Dict[int, PrimsConfiguration] = dict()  
        
        # словарь, который по множеству Steps(CONF) (которое описывает расположение соседей конфигурации CONF) хранит его номер,
        # он понадобится для определения характеристики типа (см текст диплома):
        self.STEPS: Dict[Tuple[Tuple[int, int], ...], int] = dict()
        
        # текущий свободный номер Steps(CONF)
        self.NUM_STEP: int = 0
        
        
        
    def NumerationDFS(self, I: Mesh) -> None:        
        """
        Функция, которая обходом в глубину нумерует все достижимые из I конфигурации. 
        Это реализация алгоритма 6 из текста диплома.
        
            I: ячейка, начиная с которой обходить достижимые конфигурации и нумеровать их,
            
        дополнительные данные внутри класса:
            TYPES (тип: Dict[PrimsConfiguration, int]): словарь, который по конфигурации (которую можно использовать в качестве словарного ключа, ведь в PrimsConfiguration
                    реализованы функции __eq__ и __hash__) хранит её номер (который называется тип),
            NUM (тип: int): текущий свободный номер,
            SUCCESSORS_by_TYPE (тип: Dict[int, List[Tuple[int, int, int]]]): словарь, который по номеру (типу) t хранит номера (типы) последователей
                ячейки с типом t (так как последователи зависят только от типа, ведь весь ячейчатый граф инвариантен к параллельному переносу = не зависит
                от координат), а также шаговые сдвиги, которые в них приводят,
            CONF_by_TYPE (тип: Dict[int, PrimsConfiguration]): конфигурацию храним по её номеру (типу).
        """
        
        i, j, conf = I.i, I.j, I.conf
        if conf in self.TYPES:  # если текущая конфигурация уже пронумерована, далее нет смысла идти, просто прерываем поиск текущей ветки рекурсии
            return
        
        curr_num = self.NUM  # запоминаем текущий свободный номер - это будет типом текущей конфигурации
        self.NUM += 1  # сдвигаем текущий номер для дальнейшей нумерации
        
        self.TYPES[conf] = curr_num  # нумеруем конфигурацию -> приписываем ей текущий тип curr_num
        self.CONF_by_TYPE[curr_num] = conf  # запоминаем конфигурацию с этим номером 
        self.SUCCESSORS_by_TYPE[curr_num] = []  # инициализируем список соседей для типа = curr_num, заполним его далее
        
        for J in GetSuccessors(I):
            self.NumerationDFS(J)  # рекурсивно нумеруем соседей и в следующей строке запоминаем соседей
            self.SUCCESSORS_by_TYPE[curr_num].append((self.TYPES[J.conf],  # тип соседа (= номер конфигурации ячейки J) - он уже пронумерован предыдущим вызовом DFS
                                                      J.i - i, J.j - j))  # шаговый сдвиг в соседа
        return
    
    

    def run_numbering(self) -> None:
        """
        Функция, которая запускает нумерацию. Далее фактически идёт реализация алгоритма 7 из диплома: пронумеруем все конфигурации.
        После того, как эта функция завершит работу, все словари (TYPES и тд) должны заполниться, что означает, что нумерация завершена.
        """
        
        print("Начинается нумерация конфигураций...")
        for l in range(self.theta_amount):  # перебираем номер дискретного угла
            conf_0 = StartConf(l, self.control_set)
            I0 = Mesh(0, 0, conf_0)  # формируем начальную ячейку 
            self.NumerationDFS(I0)  # нумеруем 
        print(f"Нумерация окончена! Всего достижимых конфигураций {self.NUM} штук - именно столько различных типов было назначено.")
        

    
    def start_theta(self, N: int) -> Optional[int]:
        """
        Эта функция определяет, является ли конфигурация с номером N начальной (формальнее - является ли ячейка, в которой
        конфигурация имеет номер N (= ячейка типа N), начальной). Если да, то возвращается номер дискретного угла направления,
        в котором начинаются все примитивы конфигурации (по определению: в начальной ячейке конфигурация состоит из всех
        примитивов (и степени 0 в них), начинающихся в данном дискретном направлении). В противном случае вернётся None.
        
            N: номер конфигурации, тип.
            
        Замечание: если, например, у нас используется дискретизация на 16 углов направления, то эта функция должна вернуть не None
        ровно для 16-ти различных N (так как каждому углу направления соответствует единственная начальная ячейка (по её определению), то
        есть единственна конфигурация - а у каждой конфигурации уникальный номер N).
        """
        
        conf = self.CONF_by_TYPE[N]
        conf.make_valid()
        starts = None  # угол, в котором начинаются примитивы 
        count = 0  # количество примитивов, начинающихся под углом starts
        
        for (prim, k) in conf:
            if k != 0:  # если есть примитив, который НЕ начинается в конфигурации, значит она точно не начальная
                return None
            else:
                start_theta = prim.start.theta % self.theta_amount  # номер начального угла (берём по модулю для единообразия нумерации дискретных углов)
                if (starts is not None) and (start_theta != starts):  # если в конфигурации начинается несколько примитивов под разными углами (такое в теории возможно для странного control set),
                    return None  # то это тоже не начальная конфигурация
                elif starts is None:
                    starts = start_theta
                    count = 1
                else:
                    count += 1  # добавляем к счётчику новый примитив под этим углом

        assert count == len(self.control_set.get_prims_heading(starts)), "В конфигурации не может начинаться только часть примитивов!"  # из условия 2 определения последователя конфигурации следует, 
                                                                                                                                        # что ячейка не размножается на несколько, а содержит максимально все примитивы через неё ->
                                                                                                                                        # -> если всё проводили правильно (начинали нумерацию с начальной ячейки и нумеровали только достижимые
                                                                                                                                        # конфигурации, то точно: в конфигурации если начинается один примитив, то и все тоже начинаются)                                                                                                                            
        return starts

    
    
    def goal_theta(self, N: int) -> Optional[List[int]]:
        """
        Эта функция для конфигурации с номером N возвращает, являются ли содержащие её ячейки целевыми. Если да, то
        возвращаются углы (в виде списка номеров дискретных направлений), в которых заканчиваются хотя бы один
        примитив в этой конфигурации. Если нет - возвращаем None.
        
            N: номер конфигурации, тип ячейки, которую проверяем, целевая она или нет.
            
        Замечание 1: Целевой ячейкой (по определению) называется любая, в конфигурации которой заканчивается примитив (то есть
        его степень в конфигурации максимальна). Их может быть неограниченно много (в зависимости от того, как примитивы в control
        set пересекаются и тд...) - в частности, любая начальная ячейка является целевой (так как в начальной начинаются примитивы
        по каким-то углом <=> под этим же углом какой-то примитив в ней кончился (так как именно после этого примитива начинаются следующие)). 
        
        Замечание 2: В теории в одной ячейке может заканчиваться несколько примитивов под разными углами (это снова зависит от control set). В
        этом случае эта функция вернёт все эти углы (списком), так как они понадобятся для определения целевых вершин в поиске на графе типов.
        """

        conf = self.CONF_by_TYPE[N]
        conf.make_valid()  # делаем допустимой - в этом случае те примитивы, которые кончались в конфигурации, заменились на набор
                           # начинающихся примитивов, но важно, что угол (под которыми они начинаются) остался прежним (под которым примитив кончился)
        
        finals = []  # список углов, в которых кончаются (что то же самое, что начинаются) примитивы конфигурации  
        for (prim, k) in conf:
            if k == 0:  # нашли начинающийся примитив в конфигурации
                finals.append(prim.start.theta % self.theta_amount)  # сразу добавили его начальный угол 
        
        if len(finals) == 0:
            return None
        else:
            return list(set(finals))  # переделали finals в множество (чтобы убрать дубликаты) и затем уже вернули список углов

    
    
    def get_type_angle(self, N: int) -> int:
        """
        Эта функция получает по типу N число, которое в дипломе названо углом типа.
        """
        
        conf = self.CONF_by_TYPE[N]  # получили по типу конфигурацию (у которой номер равен этому типу)
        conf.make_valid()  # сразу делаем её допустимой (чтобы зафиксировать её запись и не было вариаций далее)
        
        starts_0 = []  # дискретные углы (их номера), под которыми начинаются примитивы conf, степень которых в conf равна 0
        starts_other = []  # дискретные углы, в которых начинаются остальные примитивы conf (степень которых > 0)
        
        for (prim, k) in conf:  # перебираем примитив и его степень в конфигурации
            if k == 0:
                starts_0.append(prim.start.theta % self.theta_amount)  # приводим все углы (их номера) к одному виду - берём по модулю -> номер угла становится от 0 до self.theta_amount-1
            else:
                starts_other.append(prim.start.theta % self.theta_amount)
        
        if len(starts_0) == 0:  # если первое множество пустое, то возвращаем минимум второго
            return min(starts_other)
        else:
            return min(starts_0)
        
        
    
    def get_type_characteristics(self, N: int) -> int:
        """
        Функция получает характеристику типа.
        """
        
        # функция, которая по конфигурации conf получает множество Steps(conf):
        def steps_by_conf(conf: PrimsConfiguration) -> List[Tuple[int, int]]:
            conf.make_valid()
            steps = []
            for (prim, k) in conf:  # перебираем пары конфигурации
                a, b = step_shift(prim, k)  # смотрим шаговый сдвиг в каждом примитиве
                steps.append((a, b))  # добавляем этот сдвиг в список
            return sorted(set(steps))  # далее превращаем список в set (чтобы убрать дубликаты) и сортируем, чтобы у одинаковых (как множество) списков steps был фиксированный порядок
        
        conf = self.CONF_by_TYPE[N]  # получаем конфигурацию по её номеру
        steps = steps_by_conf(conf)  # получаем расположение соседей
        steps = tuple(steps)  # превращаем его в tuple, чтобы зафиксировать структуру и сделать возможным взятие хеша
        
        if steps not in self.STEPS:  # если это расположение ещё пронумеровано, 
            self.STEPS[steps] = self.NUM_STEP # присваиваем номер, добавляя в словарь
            self.NUM_STEP += 1  # сдвигаем нумерацию, так как данный номер уже присвоили и нужно перейти к следующему
            
        return self.STEPS[steps]  # возвращаем номер steps - это и есть характеристика типа
        
        
    
    def save_types_in_file(self, file: str) -> None:
        """
        Функция, которая производит сохранение в файл всей необходимой информации. Формат файла 
        фактически описывается в данной функции.
        
            file: имя файла, куда сохранять.
        """
        
        with open(file, "w") as f:
            
            # сначала записываем типы начальных ячеек:
            cnt = 0
            for k in range(self.NUM):  # для каждого типа k
                theta = self.start_theta(k)  # получаем номер дискретного угла, в котором начинаются примитивы в данной ячейке
                if theta is not None:  # если угол не None (значит ячейка начальная), записываем:
                    f.write(f"control-set-start with theta: {theta} has type: {k}\n")
                    cnt += 1
            assert cnt == self.theta_amount, "Количество начальный ячеек должно быть в точности равно количеству дискретных углов направления"
            
            # теперь записываем типы целевых ячеек:
            for k in range(self.NUM):
                thetas = self.goal_theta(k)  # получаем номера углов, в которых заканчиваются примитивы в конфигурации с номером k
                if thetas is not None:  # если не None, значит такой примитив есть -> ячейка типа k является целевой -> пишем в файл:
                    str_thetas = " ".join(map(str, thetas))  # собираем все углы, в которых кончаются примитивы в одну строку через пробел
                    f.write(f"in goal type: {k} ends (or equal starts) prims-in-theta: {str_thetas}\n")  # в целевой ячейке заканчивается примитив <=> начинается следующий -> в файл пишем все эти углы

            # теперь для каждого типа описываем его соседей:
            for k in range(self.NUM):
                f.write(f"start type is: {k}\n")  # выводим номер (тип ячейки) в файл
                for t, i, j in self.SUCCESSORS_by_TYPE[k]:  # перечисляем соседей этого типа (это будут последователеи на графе типов)
                    f.write(f"{i} {j} {t}\n")  # сначала пишем шаговый сдвиг (i,j) до соседа, затем его тип t
                f.write("---\n")  # Замечание: количество этих записей у каждого типа обычно небольшое (обычно <=3), именно это означает,
                                  # что исходящая степень на графе типов (да и на ячейчатом графе) небольшая.
            
            # наконец, выводим дополнительную информацию, которая позволит склеивать типовые ячейки как вершины в списке CLOSED:
            for k in range(self.NUM):
                f.write(f"add_info for type: {k} is: {self.get_type_angle(k)} {self.get_type_characteristics(k)}\n")  # выводим угол типа и характеристику типа
                                                                                                                      # (если обе этих характеристики равны, то сами типы, конечно, не обязательно равны, 
                                                                                                                      # но будем склеивать такие ячейки (у типов которых совпадают эти два числа) -> получится ускорение)

        
        
# ===================================================================
# ============= ЗАПУСК АЛГОРИТМА ====================================
    
files_control_set = ["main_control_set.txt", "short_control_set.txt", "big_control_set.txt"]  # файлы с примитивами
files_for_types = ["main_types.txt", "short_types.txt", "big_types.txt"]  # соответственно файлы, куда записать нумерацию конфигураций примитивов каждого файла

print("Начало выполнения...")

for prim_file, types_file in zip(files_control_set, files_for_types):
    #prim_file =   # файл с примитивами control_set 
    #types_file =   # файл, куда сохранять типы

    theta_16 = Theta()  # фиксируем дискретизацию
    control_set = ControlSet(theta_16).load_primitives(prim_file)  # загружаем примитивы, получаем control set
    print("Дискретизация угла зафиксирована, примитивы загружены!")

    algorithm = MainProcedureNumbering(control_set)
    algorithm.run_numbering()
    algorithm.save_types_in_file(types_file)  # нумеруем и сохраняем

print("Работа алгоритма завершена!")




