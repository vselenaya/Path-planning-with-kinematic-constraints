"""
В данном файле перечислены основные структуры данных, необходимые в поиске кинематически-согласованной траектории:
    State: Состояние мобильного агента
    DiscreteState: Дискретное состояние мобильного агента (= вершина графа state lattice)
    ShortTrajectory: Короткая траектория, класс для её генерации
    Primitive: Примитив движения (уже сгенерированный)
    Theta: Дискретизация угла направления
    ControlSet: Набор control set уже сгенерированных примитивов из дискретных состояний вида (0,0,theta_l)
    TypeMesh: Типовая ячейка (= вершина графа типов)
    TypeInfo: Структура для хранения все информации о типах ячеек, соседях для каждого типа
"""




import numpy as np
from scipy.integrate import quad
import copy

# следующие import нужные только для того, чтобы указывать типы данных в функциях (это является дополнительным контролем за
# программистом, чтобы нигде не ошибиться) -> можно и без всяких типов (это же Питон), но с ними меньше вероятности ошибки:
from typing import List  # позволяет указывать тип как список однотипных переменных: запись x: List[int] означает, что x - это список (неограниченного) размера, каждый элемент которого имеет тип int
# from typing import Self  # позволяет указывать возвращаемый тип из функции, которая должна вернуть self 
from typing_extensions import Self  # Self появился в typing только в 3.11 Питон... в ранних версиях используем typing_extensions
from typing import Tuple, Optional




class State:
    """
    Класс для описания 4-ёх мерного состояния мобильного агента: координаты, угол направления, кривизна
    """
    
    def __init__(self, x: float, y: float, theta: float, k: float = 0.0) -> None:
        self.x = x
        self.y = y
        self.theta = theta
        self.k = k
    



class DiscreteState:
    """
    Класс для описания дискретного состояния: две целочисленные координаты (i,j) и номер дискретного направления
    (дискретные состояния как вершины state lattice обязательно имеют нулевую кривизну - так дискретизацию проводили).
    """
    
    
    def __init__(self, i: int, j: int, theta: int) -> None:
        self.i = i
        self.j = j
        self.theta = theta
        
    
    def __eq__ (self, other: 'DiscreteState') -> bool:  #  используем forward references (запись типа в кавычках), чтобы указать тип DiscreteState, который ещё не дописан  
        """
        Функция проверки равенства двух состояний (вызывается при написании ==, например). Эта функция
        понадобится для использования DiscreteState (как вершины графа state lattice) при поиске, точнее - в момент
        вставки в CLOSED (который будет реализован как set()). 
        
            other: другой экземпляр класса DiscreteState, с которым нужно проверить равенство текущего экземпляра, то есть self 
                (функция должна вернуть то, что мы хотим от проверки self == other).
        """
        
        return (self.i == other.i) and (self.j == other.j) and (self.theta == other.theta)  # два состояния считаем равными только, если все компоненты равны
       
    
    def __hash__ (self) -> int:
        """
        Функция хеширования. Она должна возвращать некоторое число, которое будет использоваться для адресации
        DiscreteState (как вершин state lattice) в хеш-таблице (которой будет список CLOSED).
        Смысл в том, что у разных (то есть не равных с точки зрения предыдущей функции __eq__) DiscreteState хеши должны
        с наибольшей вероятностью отличаться (чем больше, тем быстрее функционирует хеш-таблица), а у равных - обязательно совпадать.
        Замечание: обе функции (__eq__ и __hash__) необходимо реализовать в любом классе, который будет выступать в качестве
        ключей словаря dict() или элементов хеш-множества set(). 
        """
        
        return hash((self.i, self.j, self.theta))  # хешируем набор (tuple) из компонентов
        
      
   
      
class ShortTrajectory:
    """
    Класс для хранения и генерации короткой допустимой траектории между двумя состояниями. 
    
    Короткая траектория задаётся начальным состоянием start (откуда она выходит) и своими параметрами
    (есть две параметризации, как описано в тексте диплома). В рамках кода удобно также хранить целевое состояние goal,
    куда траектория в идеале (при подобранных параметрах) "должна была бы идти" - но реальное состояние, в котором она
    кончается получается функцией final_state.
    
    Задача построения короткой траектории (подбор параметров многомерным методом Ньютона) как раз заключается в том, чтобы
    подобрать параметры такие, чтобы final_state стал равен goal.
    
    Таким образом, этот класс используется следующим образом: сначала фиксируются конкретное начальное состояние и целевое состояние, в
    котором должна траектория кончаться. Далее запускается оптимизация, которая подбирает параметры, чтобы final_state стал равен goal.
    """
    
    
    def __init__(self, start: State, goal: State) -> None:
        """
        Инициализация.
        
            start: начальное состояние, из которого выходит траектория,
            goal: состояние, в которое "в идеале" должна идти траектория.
        """
        
        # фиксированные кончики траектории:
        self.start = start
        self.goal = goal
        self.k0 = self.start.k  # начальная кривизна
        
        # первая параметризация короткой траектории: a, b, c - коэффициенты кривизны и длина:
        self.a = None
        self.b = None
        self.c = None
        self.length = None

        # вторая параметризация траектории: значения кривизны в трёх точках и логарифм длины:
        self.log_length = None
        self.k1 = None
        self.k2 = None
        self.kf = None

        # векторизуем функции получения координат (x,y) точки на траектории, чтобы можно было получать 
        # сразу набор координат по набору переменных s (точки на траектории):
        self.vect_x = np.vectorize(self.x)
        self.vect_y = np.vectorize(self.y)
        

    def set_coef_params(self, a: float, b: float, c: float, length: float) -> Self:
        """
        Фиксируем параметры короткой траектории с помощью первой (1) параметризации.
        
            a, b, c: параметры полиномиальной кривизны (определяют геометрию траектории),
            length: длина траектории.
        """
        
        assert length >= 0, "Длина не может быть отрицательна!"  # длина всегда неотрицательна
        
        # устанавливаем параметры первой параметризации:
        self.length = length  
        self.a = a
        self.b = b
        self.c = c
        
        # вычисляем параметры второй:
        self.log_length = np.log(length)
        self.k1 = self.k(1/3 * length)
        self.k2 = self.k(2/3 * length)
        self.kf = self.goal.k  # удобство второй параметризации в том, что один параметр - конечная кривизна - сразу однозначно задан из goal 

        return self
        

    def set_curve_params(self, k1: float, k2: float, log_length: float) -> Self:
        """
        Фиксируем параметры через вторую (2) параметризацию.
        
            k1, k2: значения кривизны в двух точках,
            log_length: логарифм длины кривизны.
        """
        
        # устанавливаем параметры второй параметризации:
        self.log_length = log_length
        self.k1 = k1
        self.k2 = k2
        self.kf = self.goal.k
        
        # вычисляем параметры первой параметризации:
        self.length = np.exp(log_length)
        vect_s = np.array([0, 1/3 * self.length, 2/3 * self.length, self.length]).reshape(-1, 1)
        mat_s = np.hstack((vect_s ** 0, vect_s ** 1, vect_s ** 2, vect_s ** 3))  # получаем матрицу
        params = np.linalg.inv(mat_s) @ np.array([self.k0, self.k1, self.k2, self.kf])  # делаем переход от второй параметризации к первой
        k0, a, b, c = params                                                            # (см. текст диплома)
        self.a, self.b, self.c = a, b, c  # устанавливаем параметры
        assert k0 == self.k0, "Что-то не так, кривизна k0 не меняется сменой параметризации!"  # проверяем, что всё корректно: полученное k0 - тот же самый, что был до этого в первой параметризации
                                                                                               # (это просто одна и та же переменная, которая для удобства участвует в смене параметризации, но сама не меняется)
        return self


    """
    При фиксированном начальном состоянии start, а также фиксированных параметрах первой параметризации, 
    однозначно определяются функции, задающие короткую траекторию. Все эти функции зависят от s - точки на кривой
    (s = длина пройденного кусочка от начала кривой) и имеют вид (подробнее - см. текст диплома): 
        кривизна - полиномиальная функция, 
        угол направления - полином 4 степени,
        координаты x и y - интегралы от cos и sin угла направления.
    
    Следующие четыре метода по точке s получают значения этих функций в ней: кривизна, угол направления, координаты.
    """
    
    
    def k(self, s: float) -> float:
        """
        Получение значения кривизны в точке s.
            s: точка на траектории 
        """
        
        assert s >= 0, "Параметр s должен быть неотрицателен!"  # длина пройденного куска неотрицательна
        return self.k0 + self.a * s + self.b * s**2 + self.c * s**3  # считаем значение полиномиальной кривизны
    
    
    def theta(self, s: float) -> float:
        """
        Получение значения угла направления в точке s.
            s: точка на траектории
        """
        
        assert s >= 0, "Параметр s должен быть неотрицателен!"
        theta0, k0 = self.start.theta, self.k0
        a, b, c = self.a, self.b, self.c
        return theta0 + k0 * s + a/2 * s**2 + b/3 * s**3 + c/4 * s**4  # используем уравнения угла направления


    def x(self, s: float) -> float:
        """
        Получение координаты x в точке s.
            s: точка на траектории
        """
        
        assert s >= 0, "Параметр s должен быть неотрицателен!"
        x0 = self.start.x
        return x0 + quad(lambda x: np.cos(self.theta(x)), 0, s, limit=200, limlst=10)[0]  # вычисляем интеграл численно
    
    
    def y(self, s: float) -> float:
        """
        Получение координаты y в точке s.
            s: точка на траектории
        """
        
        assert s >= 0, "Параметр s должен быть неотрицателен!"
        y0 = self.start.y
        return y0 + quad(lambda x: np.sin(self.theta(x)), 0, s, limit=200, limlst=10)[0]


    # семплирование координат x и y на траектории с шагом (расстояние между соседними точками) ds:
    def sample_x(self, ds: float = 0.02) -> np.ndarray:
        num = int(self.length / ds)
        return self.vect_x(np.linspace(0, self.length, num=num, endpoint=True))  # endpoint=True, чтобы конечная точка (координаты финального состояния) тоже была
    
    def sample_y(self, ds: float = 0.02) -> np.ndarray:
        num = int(self.length / ds)
        return self.vect_y(np.linspace(0, self.length, num=num, endpoint=True))  # т.к. функции x и y векторизованы, можем сразу набор (np.ndarray) координат считать по множеству точек s


    def state(self, s: float) -> State:
        """
        Функция для получения состояния мобильного агента, находящегося в точке s (= на удалении s от старта) траектории. 
        
            s: точка на траектории
        
        Замечание: Вообще траектория определяется как функция изменения состояния агента, поэтому здесь получаем фактически её значение
        в точке s. Координаты же (x,y) это положение на траектории, рассматриваемой как кривая в рабочем пространстве (и получающаяся
        проекцией исходной функции состояния на плоскость карты). Это означает, что если нарисовать эту кривую (например, просто отметив
        много-много точек (x,y) с маленьким шагом - что делает функция sample_x и sample_y), то при движении по ней у мобильного агента
        будет меняться состояние согласно траектории (то есть координаты будут меняться как x(s),y(s) (но это и так ясно - мы так
        кривую из этих точек нарисовали), угол направления будет изменяться как theta(s) (а угол направления = угол между касательной
        к кривой и ось абсцисс), кривизна изменится как k(s)) - просто потому, что эта кривая является проекцией траектории.
        """
        
        return State(self.x(s), self.y(s), self.theta(s), self.k(s))  # собираем состояние в точке s из компонент: координат, угла направления и кривизны
                                                                      # (проекцией этого состояния на плоскость рабочего пространства будет просто пара точек x(s),y(s))


    def final_state(self) -> State:
        """
        Функция для получения состояния, в котором заканчивается короткая траектория, выходящая из start
        и имеющая заданные параметры.
        
        Цель оптимизации (подбора параметров) в том, чтобы goal = final_state
        """
        
        return self.state(self.length)
    
    
    
    
class Primitive:
    """
    Этот класс нужен только для хранения уже сгенерированного примитива движения. 
    Примитивом является короткая допустимая траектория между двумя дискретными состояниями.
    """
    
    
    def __init__(self, start: DiscreteState, goal: DiscreteState) -> None:
        """
        Инициализация.
        
            start: дискретное начальное состояние, из которого идёт примитив,
            goal: дискретное состояние, в которое идет примитив.
        """
        
        # фиксированные кончики примитива:
        self.start = start
        self.goal = goal
        
    
    def set_description(self, x_coords: np.ndarray, y_coords: np.ndarray, length: float, 
                              i_coords: np.ndarray, j_coords: np.ndarray, turning: int) -> Self:
        """
        Сохраняем всю информацию о примитиве.
        
            x_coords, y_coords: два массива координат (x,y) точек на примитиве, взятых с мелким шагом (близко друг к другу)
                                (нужны только, чтобы отрисовать примитив как кривую на картинках),
            length: длина примитива как куска кривой,
            collision_in_i, collision_in_j: два массива номеров клеток (i,j) дискретного рабочего пространства, по которым проходит примитив
                                (фактически, это коллизионный след примитива; нужен, например, для проверки коллизии)
            turning: угол, на который поворачивает мобильный агент при движении по примитиву (считается в количестве дискретных углов между
                                            стартовым направлением и целевым)
        
        Замечание: Так как примитив (как короткая траектория) генерируется на плоскости, где ось Y направлена вверх, то и i-координата
        в collision_in_i считается растущей вверх. Чтобы не запутаться, можно всегда считать, что оси y и i направлены вверх, но при поиске
        траектории на дискретной карте (которая хранится как матрица, поэтому нумеруется сверху вниз) просто перевернуть все примитивы - для
        этого достаточно перевернуть углы (использовать -theta_l вместо theta_l)    
        """
        
        assert x_coords.shape == y_coords.shape, "Количество x и y координат должно совпадать, так как они образуют точки (x,y)!"
        assert i_coords.shape == j_coords.shape, "Количество i и j координат должно совпадать, так как из них получаются клетки (i,j) коллизионного следа!"
        assert (i_coords[0] == self.start.i) and (j_coords[0] == self.start.j), "Первая клетка коллизионного следа, очевидно, должна совпадать с проекцией стартового состояния!"
        
        self.x_coords = x_coords
        self.y_coords = y_coords
        self.length = length
        self.collision_in_i = i_coords
        self.collision_in_j = j_coords
        self.turning = turning
        self.U = len(i_coords)  # количество клеток коллизионного следа
        assert self.U >= 2, "Примитив не может занимать меньше 2 клеток коллизионного следа!"
        
        return self
    
    
    def __eq__ (self, other: 'Primitive') -> bool:
        """
        Функция сравнения на равенство двух примитивов. Мы считаем, что между двумя дискретными состояниями может быть только один 
        единственный примитив! (это логично, тк дискретное состояние полностью характеризует мобильный агент -> нет смысла две разных траектории
        между одинаковыми состояниями делать.... более того, имеющийся в данной работе способ генерации коротких траекторий по двум фиксированным
        состояниям не сможет сгенерировать более одной траектории). Поэтому два примитива равны тогда и только тогда, когда равны
        начальные и конечные состояния.
        
        Замечание: если всё же хочется иметь между двумя состояниями несколько разных примитивов, нужно переписать эту функцию
        сравнения как-нибудь сложнее (например, сравнивать поточечно координаты).
        """
        
        return (self.start == other.start) and (self.goal == other.goal)  # можем писать ==, так как в DiscreteState определена функция __eq__
    
    
    def __hash__ (self) -> int:
        """
        Функция, возвращающая хеш (некоторое число, сопоставленное объекту) примитива. Хеш должен соответствовать проверке
        на равенство __eq__ в том смысле, что у равных примитивов хеш тоже обязательно должен совпадать. Для этого просто хешируем
        набор начального и целевого состояний вместе.
        
        Благодаря функциям __eq__ и __hash__ теперь можно использовать примитив (как экземпляр данного класса) в качестве ключа словаря, например.
        """
        
        return hash((self.start.i, self.start.j, self.start.theta, self.goal.i, self.goal.j, self.goal.theta))  # хеш от длинного набора
    
        
        
        
class Theta:
    """
    Класс для хранения дискретного угла направления (дискретизация на 16 вариантов направления). Если хочется
    создать другую дискретизацию, нужно переписать данный класс.
    """
    
    
    def __init__(self) -> None:
        self.theta_amount = 16  # количество углов дискретизации
        self.theta_16 = np.zeros(16)  # заводим массив, где по номеру {0,...,15} будем получать угол дискретного направления
        
        for i in range(0, 16, 2):
            self.theta_16[i] = np.deg2rad(i / 16 * 360)  # 8 дискретных направлений идут равномерно с шагом 45°
            
        self.theta_16[1] = np.arctan(1 / 2)  # ещё 8 направлений - повороты и отражения угла arctg(1/2)
        self.theta_16[3] = np.arctan(2)
        self.theta_16[5] = self.theta_16[1] + np.pi / 2
        self.theta_16[7] = self.theta_16[3] + np.pi / 2
        self.theta_16[9] = self.theta_16[1] + np.pi
        self.theta_16[11] = self.theta_16[3] + np.pi
        self.theta_16[13] = self.theta_16[5] + np.pi
        self.theta_16[15] = self.theta_16[7] + np.pi 
        
        for i in range(16):
            self.theta_16[i] = self.correct_angle(self.theta_16[i])   # чтобы все дискретные углы были в диапазоне от -pi до pi
         
        
    def correct_angle(self, angle: float) -> float:
        """
        Функция, которая переводит поданный на вход угол в интервал [-\pi, \pi)
        (все углы рассматриваются с точностью до полного оборота = 2\pi, поэтому для однозначного
        задания угла можно выбрать любой интервал длины 2\pi -> выбрали [-\pi, \pi) и рассматриваем углы только в таком интервале).
        
            angle: угол, который подаётся на вход
        """

        angle %= (2 * np.pi)
        if angle > np.pi:
            angle -= 2 * np.pi
        return float(angle)
    
    
    def __getitem__(self, ind: int) -> float:
        """
        При обращении к экземпляру класса по индексу ind будем возвращать дискретный угол этого номера
        """
        
        ind = ind % 16  # нумерация циклична по модулю 16
        return self.theta_16[ind]
        

    def num_angle(self, angle: float) -> int:
        """
        По углу получаем его дискретный номер от 0 до 15.
        
            angle: угол дискретного направления.
        """
        
        EPS = 1e-6  # точность проверки угла
        angle = self.correct_angle(angle)
        
        for i in range(16): 
            if (angle - EPS <= self[i] <= angle + EPS):      
                return i
        else:
            raise Exception(f"Угол {angle} не является дискретным направлением!\n")
        
    
    def dist(self, angle1: float, angle2: float) -> int:
        """
        Получаем расстояние между двумя дискретными углами (расстояние в количестве дискретных направлений от одного до другого).

            angle1, angle2: два угла дискретных направлений.
        """
        
        l1 = self.num_angle(angle1)  # номера углов 
        l2 = self.num_angle(angle2)
        
        return min(abs(l1 - l2), 16 - abs(l1 - l2))  # расстояние с учёт цикличности по модулю 16
    
    
    def num_dist(self, l1: int, l2: int) -> int:
        """
        Получаем расстояние между двумя номерами дискретных углов.

            l1, l2: два номера дискретных направлений.
        """
        
        l1 %= 16  # углы отсчитываются циклично по модулю 16
        l2 %= 16
        
        return min(abs(l1 - l2), 16 - abs(l1 - l2))  # расстояние с учёт цикличности по модулю 16
        
    
    

class ControlSet:
    """
    Класс для хранения набора сгенерированных примитивов (экземпляров Primitive) control set.
    
    Замечание: Все примитивы в control set начинаются из дискретного состояния (0,0,theta_l). При этом траектории (на графе state
    lattice, например) строятся из копий этих примитивов (которые могут выходить из состояний с ненулевыми координатами), полученных
    параллельным переносом. Если нужно описать такую копию (например как часть цепочки в траектории), которая выходит из состояния 
    с ненулевыми координатами (i,j,theta_l), то достаточно помнить примитив из данного control set, а также пару координат (i,j), на
    которую параллельным переносом его нужно сдвинуть (это экономит память, не нужно плодить экземпляры Primitive).
    """
    
    
    def __init__(self, theta_discretization: Theta) -> None:
        """
        Инициализация.
        
            theta_discretization: получаем экземпляр класса Theta, конкретная дискретизация угла направления.
        """
        
        self.theta = theta_discretization
        self.theta_amount = theta_discretization.theta_amount  # количество дискретных направлений
        self.control_set = []  # создаём массив, в котором будут храниться все сгенерированные примитивы как экземпляры класса Primitive().
        
        for i in range(self.theta_amount):  # для каждого дискретного угла направления i будет храниться список примитивов, выходящих под этим
                                            # углом - то есть те примитивы control set, которые начинаются в дискретном состоянии (0,0,i)
            self.control_set.append([])


    def get_prims_heading(self, heading: int) -> List[Primitive]:
        """
        Функция, которая по номеру дискретного угла направления heading получает список примитивов control set,
        выходящих под этим углом.
        
            heading: число, номер дискретного направления.
        """
        
        heading %= self.theta_amount  # так как у нас нумерация углов по модулю (например, циклично по модулю 16), то делаем так
        return self.control_set[heading]
    
    
    def get_prim_between_states(self, start: DiscreteState, goal: DiscreteState) -> Primitive:
        """
        Функция, которая получает конкретный примитив между двумя дискретными состояниями. Фактически эта функция получает
        ребро графа state lattice между двумя конкретными вершинами.
        
            start, goal: два дискретных состояния (= вершины state lattice), между которыми ищем примитив.
            
        Замечание: все рёбра (примитивы) графа state lattice получаются раскопированием (параллельным переносом) исходного control set
        по всем дискретным состояниям. Поэтому эта функция должна сначала найти соответствующий примитив control set, а затем вернуть его копию,
        полученную параллельным переносом, чтобы он шёл из start в goal.
        """
        
        di, dj = goal.i - start.i, goal.j - start.j  # получаем, в какие координаты идёт примитив, если параллельным переносом start перенести в координаты (0,0)
        
        for prim in self.get_prims_heading(start.theta):  # перебираем примитивы control set из данного начального угла
            if (self.theta.num_dist(goal.theta, prim.goal.theta) == 0 and
                prim.goal.i == di and
                prim.goal.j == dj):  # если примитив заканчивается под нужным дискретным углом и в нужных координатах -> нашли нужный примитив control set
                
                find_prim = Primitive(start, goal)  # создаём новый примитив (уже не из control set, а конкретный примитив между состояниями - он будет копией prim, сдвинутый параллельным переносом в start)
                x_coords = copy.deepcopy(prim.x_coords) + start.j  # параллельным переносом сдвигаем координаты примитива, чтобы он и правда шёл из start в goal
                y_coords = copy.deepcopy(prim.y_coords) + start.i            # (помним, что i-ось и y-ось у примитива направлена одинаково вверх)
                collision_in_i, collision_in_j = [], []
                for i, j in zip(prim.collision_in_i, prim.collision_in_j):
                    collision_in_i.append(i+start.i)
                    collision_in_j.append(j+start.j)
                collision_in_i = np.array(collision_in_i)
                collision_in_j = np.array(collision_in_j)
                    
                find_prim.set_description(x_coords, y_coords, prim.length,
                                          collision_in_i, collision_in_j, prim.turning)  # фиксируем данные примитива после переноса

                return find_prim  # просто возвращаем найденный примитив
                                  # заметим, что продолжать перебор далее нет смысла, так как мы считаем, что между двумя состояниями может быть только один примитив (что логично)
        
        #print(start.i, start.j, start.theta)
        #print(goal.i, goal.j, goal.theta)
        raise Exception(f"Примитив не найден! Был запрос поиска между состояниями: {start.i, start.j, start.theta} и {goal.i, goal.j, goal.theta}")  # если не нашли примитив, сообщаем об этом
    

    def load_primitives(self, file: str) -> Self:    
        """
        Функция, читающая примитивы из файла и заполняющая control_set. Файл имеет тот формат, что генерируется в create_prims_file.py

            file: имя файла, откуда читать примитивы.
        """  
        
        with open(file, "r") as f:
            curr_prim_x = []
            curr_prim_y = []
            i_collisions = []
            j_collisions = []
            theta = None  # угол, под которым выходит примитив (номер дискретного угла)
            goal = None  # дискретное состояние, куда идёт примитив
            length = None  # его длина
            turning = None  # то, насколько он поворачивает
            
            while True:
                line = f.readline()
                if line == "":
                    break
                
                if "===== prim description: =====" in line:
                    curr_prim_x.clear()
                    curr_prim_y.clear()
                    i_collisions.clear()
                    j_collisions.clear()
                    continue

                if "start heading (number):" in line:
                    theta = int(line.split(": ")[1])
                    
                if "goal state (i, j, heading num):" in line:
                    p = list(map(int, (line.split(": ")[1]).split(" ")))
                    goal = DiscreteState(*p)

                if "length is:" in line:
                    length = float(line.split(": ")[1])

                if "turning on:" in line:
                    turning = int(line.split(": ")[1])

                if "trajectory is:" in line:
                    while True:
                        line = f.readline()
                        if "---" in line:
                            break
                        curr_prim_x.append(float(line.split()[0]))
                        curr_prim_y.append(float(line.split()[1]))

                if "collision is:" in line:
                    while True:
                        line = f.readline()
                        if "---" in line:
                            break
                        i_collisions.append(int(line.split()[0]))
                        j_collisions.append(int(line.split()[1]))
                        
                if "prim end" in line:
                    prim = Primitive(DiscreteState(0, 0, theta), goal)  # создаём примитив control set, координаты стартового состояния всегда считаем 0
                    prim.set_description(np.array(curr_prim_x), np.array(curr_prim_y), length,
                                         np.array(i_collisions), np.array(j_collisions), turning)
                    
                    self.control_set[theta].append(prim)  # добавляем новый примитив для нужного угла

        return self




class TypeMesh:
    """
    Типовая ячейка.
    """
    
    def __init__(self, i: int, j: int, type: int) -> None:
        """
        Инициализация.
        
            i,j: дискретные координаты клетки,
            type: тип (= номер конфигурации примитивов) этой ячейки.
        """
        
        self.i = i 
        self.j = j
        self.type = type
        
        
        
        
class TypeInfo:
    """
    Данный класс предназначен для хранения информации о типах, которая загружается из файла.
    """
    
    
    def __init__(self, control_set: ControlSet, max_types=3000):
        """
        Инициализация. Создаём структуры для хранения данных.
        
            control_set: набор примитивов, который используется (из которого получились типы),
            max_types: максимальное количество типов, удобно для инициализации списков.
        """
        
        self.control_set = control_set
        self.max_types = max_types
        
        # список, где по номеру type (типу) в качестве индекса получаем список соседей вида (di, dj, t) - шаговый сдвиг в него и его тип:
        self.successors: List[Tuple[int, int, int]] = list(range(max_types)) 
        
        # по номеру угла получаем тип начальной ячейки, в конфигурации которой начинаются примитивы control set для этого угла:
        self.start_type: List[int] = list(range(self.control_set.theta_amount))  
        
        # по type получаем список углов theta, в которых заканчиваются примитивы в конфигурации с номером type (и None, если никакой примитив не кончается):
        self.goal_theta_by_type: List[Optional[int]] = [None] * max_types
        
        # по type получаем дополнительные значения, по которым можно склеивать вершины:
        self.add_info_type: List[int] = list(range(max_types))  


    def load_types(self, file: str) -> Self:
        """
        Данная функция читает файл с типами (=номерами конфигураций) и заполняет структуры. В качестве формата файла используется тот,
        каким этот файл генерировали при нумерации конфигураций в numbering_configuration.py
        
            file: имя файла, откуда загружать типы.
        """
        
        with open(file, "r") as f:
            while 1:  # в цикле читаем по строчке файла
                line = f.readline()
                if line == "":  # если дошли до конца файла, 
                    break
                    
                if "control-set-start with theta:" in line:
                    theta, type = int(line.split()[3]), int(line.split()[-1])
                    self.start_type[theta] = type
                    continue
    
                if "in goal type:" in line:
                    type = int(line.split()[3])
                    thetas = list(map(int, line.split()[9:]))
                    self.goal_theta_by_type[type] = thetas
                    continue
                    
                if "start type is:" in line:
                    type = int(line.split()[-1])
                    self.successors[type] = []
                    while 1:
                        line = f.readline()
                        if "---" in line:
                            break
                        i, j, t = map(int, line.split())
                        self.successors[type].append((i, j, t))
                    continue
    
                if "add_info for type:" in line:
                    type = int(line.split()[3])
                    info = 0
                    for i in tuple(map(int, line.split()[5:])):
                        info = info * 1000 + i  # все числа дополнительной информации (например угол типа и характеристику типа) склеиваем в одной число, чтобы удобнее
                                                # (считаем, что числа доп информации < 1000, поэтому умножаем так)
                    self.add_info_type[type] = info
                    continue
        return self
