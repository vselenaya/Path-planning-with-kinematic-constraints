"""
Здесь перечислены основные структуры и функции, необходимые для поиска на графе алгоритмом A*.
В общем и целом, в данном файле реализован раздел 2.6 (алгоритмы поиска на графе) текста диплома.
"""




import numpy as np
from heapq import heappop, heappush
from typing_extensions import Self
from typing import Optional  # запись x: Optional[int] означает, что переменная x может принимать тип int или быть None
from typing import Callable  # позволяет задавать тип функции: например, Callable[[int], str] указывает функцию, которая принимает на вход один аргумент типа int и возвращает строку str
from typing import Union  # позволяет указывать несколько типов для одной переменной: запись Union[int, float] позволяет переменной быть типа либо int, либо float
from KC_structs import *




class Map:  
    """
    Класс для хранения карты (дискретного рабочего пространства), которая считается прямоугольником из клеток. Она хранится в виде
    бинарной матрицы, где индексация будет по координатам (i,j), где i - номер строки (считается сверху вниз), j - номер столбца.
    Элемент на позиции (i,j) равен 1 (если соответствующая клетка (i,j) рабочего пространства занята) или 0 (иначе). 
    
    Замечание: так как в матрице номер строки i считается сверху вниз (первая строка имеет номер 0 и далее вниз увеличивается),
    то и в рабочем пространстве первая координата клетки будет считаться так же (i ось направлена вниз). Направление осей вообще не
    играет никакой роли с точки зрения алгоритмов (им главное, что есть две координаты, а как они считаются - не важно), но если
    использовать имеющиеся (в ControlSet) примитивы (при генерации которых ось i считалось направленной вверх - при заполнении
    поля collision_in_i, например) и соответствующую дискретизацию угла (тот параметр theta_discretization, который передавался в ControlSet),
    то будет один нюанс: на карте угол направления будет расти от горизонтали по часовой стрелке (то есть, например, угол=45° будет указывать
    вниз-вправо, а не вверх-вправо как обычно), а не против как обычно. Единственное, к чему это приведёт - непривычный для пользователя
    вид траектории (он, например, укажет стартовое направление 45°, а траектория на карте пойдёт в направлении вниз) и всё! (а алгоритмы,
    примитивы и тд будут работать как обычно...). Таким образом, если хочется всё-таки построить траекторию под начальным углом (в привычном
    понимании, отсчитываемом против часовой от горизонтали) theta_l, то достаточно изменить  его на -theta_l и всё - дальше алгоритмы сработают
    сами (ничего делать с примитивами не нужно, так как они не знают ни о каких направлениях -> достаточно изменить начальный угол
    на -theta_l и дальше их цепочка сама пойдёт в нужно направлении, создав требуемую траекторию).
    """
    
    
    def __init__(self) -> None:
        """
        Инициализация.
        """
        
        self.cells = None  # бинарная матрица рабочего пространства, пока нет её       
             
    
    def convert_string_to_cells(self, cell_str: str, obs: bool = True) -> Self:
        """
        Функция, которая считывает карту, заданную в виде строки. Строка является набором из нескольких линий (разделённых символом
        перевода строки \n), каждая линия отвечает за очередной ряд клеток дискретного пространства. Пространство считается прямоугольным,
        поэтому длина линий должна быть одинаковой.
        
            cell_str: строка, задающая карту (в ней . - свободная клеточка, # или @ - занятая;  \n - перевод на следующий ряд клеток),
            obs: нужно ли учитывать препятствия (если False, то игнорируем # и @, считывая карту как будто полностью пустую).
        """
        
        cell_str = cell_str.replace("\r\n", "\n")  # в Windows перевод строки делается через \r\n -> заменяем на просто \n (перевод строки в POSIX)
        cell_lines = cell_str.split("\n")  # получаем массив линий - каждая линия является строкой, отвечающей за очередной ряд клеток карты
        
        cells_list = []  # двумерный бинарный массив клеток (0 - свободна, 1 - занята)

        for line in cell_lines:  # проходимся по рядам 
            if len(line) == 0:  # игнорируем пустые ряды
                continue
            if line[0] not in ['.', '@', '#']:  # игнорируем ряды, начинающиеся не с символа карты (так как это могут быть строки с информацией о размерах карты, названии и тп)
                continue
            
            cells_row = []
            
            for char in line:  # проходимся по символам, отвечающим за клетку ряда
                if char == '.':  # свободная клетка
                    cells_row.append(0)
                elif (char == '#') or (char == '@'):  # занятая клетка
                    if obs:
                        cells_row.append(1)
                    else:  # если obs=False, клетку считаем свободной (препятствия не рассматриваем)
                        cells_row.append(0)
                elif (char == ' '):  # пробелы игнорируем
                    continue
                else:
                    raise Exception(f"Неизвестный символ {char} в записи карты!\n")
                
            cells_list.append(cells_row)
            
        self.cells = np.array(cells_list, dtype=np.int8)  # получаем двумерный numpy-массив клеток
        self.width = self.cells.shape[1]
        self.height = self.cells.shape[0]  # размеры карты
        
        return self


    def in_bounds(self, i: int, j: int) -> bool:
        """
        Проверяем, находится ли клетка (i,j) в пределах карты.
            i, j: координаты клетки.
        """
        
        return (0 <= i < self.height) and (0 <= j < self.width)


    def traversable(self, i: int, j: int) -> bool:
        """
        Проверяем, является ли клетка (i,j) свободной.
            i, j: координаты клетки.
        """
        
        return (self.cells[i][j] == 0)           
    
    
    def get_slice(self, si: int, fi: int, sj: int, fj: int) -> Self:
        """
        Функция оставляет от карты только её кусок с координатами клеток (i,j), где i из [si, fi) и j из [sj, fj)
        (полезная функция, если хочется делать поиск только на куске карты, а не на всей).
        
            si, sj, fi, fj: координаты, кусок которых оставить на карте. 
        """
        
        self.cells = self.cells[si:fi, sj:fj]
        self.width = self.cells.shape[1]
        self.height = self.cells.shape[0]
        return self




"""
Поиск алгоритмом A* всегда производится на каком-то графе. В рассматриваемой дипломной работе нас интересует только два поиска:
на графе state lattice (вершины которого являются дискретными состояниями) и на графе типов (вершины которого типовые ячейки).
Определим тип данных вершины графа, в качестве которой может быть DiscreteState или TypeMesh:
type VertexType = Union[DiscreteState, TypeMesh]  # оказалось, это работает только в 3.12 версии питона, поэтому обойдёмся без этого
"""





class SearchNode:
    """
    Класс вершины поиска Search Node, которая используется в алгоритме A*. 
    Фактически Search Node является обёрткой над вершиной графа (на котором производится поиск), которая содержит
    дополнительную информацию вроде f-,g-,h- значений, указателя на предка. Более формально - см. текст диплома.
    """
    
    
    def __init__(self, vertex: Union[DiscreteState, TypeMesh],
                 g: float = 0, h: float = 0, f: Optional[float] = None,
                 parent: Optional['SearchNode'] = None) -> None:
        """
        Инициализация.

            vertex: вершина графа, в котором производится поиск (это будет или состояние DiscreteState (если поиск 
                на state lattice в базовом решении), или TypeMesh - типовая ячейка, если поиск на графе типов)
            g, h, f: g-, h-, f=g+h- значения для вершины поиска,
            parent: указатель на родителя - то есть на Search Node, в процессе раскрытия которой (а точнее раскрытия vertex внутри неё) 
                была создана данная Search Node (parent = None, если это стартовая вершина, в неё ниоткуда не приходили)
        """
        
        self.vertex = vertex
        self.g = g
        self.h = h
        if f is None:
            self.f = self.g + h
        else:
            self.f = f        
        self.parent = parent


    def __lt__(self, other: 'SearchNode') -> bool:
        """
        Функция сравнения двух вершин (возвращает True, если первая вершина меньше второй и False иначе). Она нужна для
        структуры кучи heap, чтобы вытаскивать из неё Search Node в порядке увеличения их f-значений (так нужно для работы A*)
        """
        
        return self.f < other.f  # сравниваем по f-значению -> меньшой считаем Search Node с меньшим f-значением
    
    
    # далее определим функции __eq__ и __hash__, чтобы было возможно вставлять Search Node в хеш-таблицу set (в CLOSED, к примеру):
    # (для этого просто пробросим эти функции на уровень вершин vertex - то есть используем их функции, которые обязательно должны 
    # быть определены;  то есть __eq__ и __hash__ зависят только от vertex и никак не связаны с остальной Search Node)
    
    def __eq__(self, other: 'SearchNode') -> bool:
        return self.vertex == other.vertex  # в качестве равенства используем равенство вершин (операция == вызывает функцию
                                            # __eq__, которая должна быть определена в вершине vertex - в DiscreteState и TypeMesh)
    
    
    def __hash__(self) -> int:
        return hash(self.vertex)  # хешируем вершину (при этом вызывается функция __hash__ вершины vertex)
    
    
    
    
class SearchTreePQD:
    """
    Класс, реализующий "дерево поиска" - структуру, реализующую списки OPEN и CLOSED для поиска A*.
    
    Замечание: В тексте диплома считали, что OPEN является хранилищем Search Node, а CLOSED только вершин vertex. Но
    удобнее на практике в CLOSED класть не только вершину, но и содержащую её Search Node - это может понадобится,
    например, чтобы визуализировать список CLOSED (нарисовать вершины и рёбра в их предков), как это было на 
    рис. 65 диплома. Единственное, если в OPEN возможны дубликаты (несколько разных экземпляров Search Node, в которых
    находятся равные вершины vertex) из-за ленивой детекции дубликатов, то в CLOSED их быть не может (так как смысл
    CLOSED в том, чтобы хранить раскрытые вершины (для возможности проверить, раскрыта ли уже данная вершина), каждую не более
    одного раза). Для этого достаточно все операции в CLOSED проводить на уровне вершин vertex, не обращая внимания на
    содержащие их Search Node (что и логично: мы как будто в CLOSED храним вершину vertex (как и было в тексте диплома),
    но исключительно для доп информации храним ещё и окружающую её Search Node...) -> чтобы такое сделать, функции __eq__ и
    __hash__ (которые обеспечивают вставку/проверку Search Node в CLOSED, в качестве которого используется set), определённые
    в классе Search Node зависят исключительно от находящейся в ней вершины vertex, а значит, CLOSED даже не "видит"
    Search Node - для него мы храним только вершины (таким образом, в CLOSED будет оказываться вершина и окружающая её Search Node,
    причём та, которая оказалось в CLOSED раньше других -> другие Search Node с этой же вершиной (дубликаты) просто отбросятся).
    """
    
    
    def __init__(self) -> None:
        """
        Инициализация.
        """
        
        self._open = []  # очередь с приоритетами (для вставки/извлечения используется heappush/heappop) для списка OPEN
                         # (где порядок элементов определяется функцией __lt__, реализованной в Search Node -> то есть 
                         # порядок будет по возрастанию f-значения, что и требуется согласно тексту диплома)
        self._closed = set()  # множество вершин (нужна для быстрой проверки наличия элемента в ней) для списка CLOSED
        self._enc_open_dublicates = 0  # количество дубликатов в списке OPEN (отладочная информация, может понадобится...)
         
                                      
    def __len__(self) -> int:
        """
        Функция, чтобы работал стандартный метод len() в Питоне от экземпляра текущего класса.
        """
        
        return len(self._open) + len(self._closed)
       
                
    def open_is_empty(self) -> bool:
        """
        Функция, проверяющая, пустой ли список OPEN.
        """
        
        return (len(self._open) == 0)
    
    
    def add_to_open(self, item: SearchNode) -> None:
        """
        Вставляем в OPEN новую вершину поиска. Здесь не проверяется, встречалась ли уже такая вершина
        ранее (то есть тут не проверяем дубликаты!). Мы проверим наличие дубликатов лениво (внутри функции get_best_node).
        
            item: новая вершина поиска, экземпляр класса SearchNode.
        """
        
        heappush(self._open, item)  # для вставки используем стандартную функцию Питона heappush, которая реализует очередь с приоритетами
        
    
    def add_to_closed(self, item: SearchNode) -> None:
        """
        Вставляем вершину (а точнее содержащую её Search Node) в CLOSED. Это означает, что вершина уже раскрыта.
        
            item: Search Node вместе с раскрытой вершиной внутри.
        """
        
        self._closed.add(item)  # добавляем в словарь (тут используется __hash__ и __eq__ из Search Node)


    def was_expanded(self, item: SearchNode) -> bool:
        """
        Проверка, раскрыта ли вершина - то есть в CLOSED она или нет?
        
            item: Search Node, вершину vertex внутри которой проверяем на раскрытие
            (то есть, хоть на вход подаётся целая Search Node, проверка производится только на уровне вершин vertex).
        """
        
        return item in self._closed  # так как CLOSED - это set(), то такая проверка должна быть быстрой.


    def get_best_node_from_open(self) -> Optional[SearchNode]:
        """
        Достаём лучшую Search Node (по f-значению) из OPEN.
        """
        
        while True:
            best_node = heappop(self._open)  # извлекаем лучшую вершину поиска (вершину с минимальным f-значением), это делается heappop
            if not self.was_expanded(best_node):  # если вершина внутри Search Node ещё не раскрыта, возвращаем результат
                return best_node            
            if self.open_is_empty():  # такое получается, если задача не имеет решения (OPEN кончился, так как все вершины раскрыли) - пути нет
                return None
            
            # если ранее не вышли из цикла, значит вынутая Search Node - дубликат (так как хранящаяся внутри неё вершина уже
            # находится внутри CLOSED, то есть уже раскрыта) -> её отбрасываем (ленивая проверка дубликатов), продолжая цикл
            self._enc_open_dublicates +=1  # увеличиваем счётчик дубликатов
        

    # ещё функции, позволяющие получить OPEN, CLOSED, число дубликатов
    @property
    def opened(self) -> List[SearchNode]:
        return self._open
    
    @property
    def expanded(self) -> List[SearchNode]:
        return list(self._closed)

    @property
    def number_of_open_dublicates(self) -> int:
        return self._enc_open_dublicates
    
    
    
      
def astar(start: Union[DiscreteState, TypeMesh], is_goal: Callable[[Union[DiscreteState, TypeMesh]], bool], 
          get_successors: Callable[[Union[DiscreteState, TypeMesh]], List[Union[DiscreteState, TypeMesh]]],
          heuristic_func: Callable[[Union[DiscreteState, TypeMesh]], float], 
          compute_cost: Callable[[Union[DiscreteState, TypeMesh]], float], 
          w: int = 1):
    """
    Функция поиска кратчайшего пути в графе (в state lattice или графе типов, например) - алгоритм A*.
    
        start: начальная вершина (DiscreteState или TypeMesh, например) графа, от которой запускается поиск,
        is_goal: функция, которая по вершине выдаёт True, если она считается целевой и False иначе,
        get_successors: функция, которая по вершине возвращает список её соседей,
        heuristic_func: по вершине считает оценку оставшегося минимального пути от неё до любой целевой,
        compute_cost: по двум соседним (между которыми есть ребро) вершинам выдаёт стоимость ребра из первой во вторую,
        w: увеличение стоимости эвристики в w раз (нужно для WA*) -> получается взвешенная эвристика.
        
    Функция возвращает:
        найден ли путь (True или False), последняя Search Node в поиске (от неё нужно восстанавливать путь по ссылка на родителя),
        количество итераций (раскрытий вершин), списки OPEN и CLOSED
    """
    
    ast = SearchTreePQD()  # создали экземпляр дерева поиска
    steps = 0  # количество итераций алгоритма
    
    start_node = SearchNode(start, h=w*heuristic_func(start))  # создали стартовую Search Node в дереве поиска
    ast.add_to_open(start_node)  # добавили её в OPEN


    # пока OPEN не закончился, делаем итерации:
    while not ast.open_is_empty():
        current = ast.get_best_node_from_open()  # взяли очередную вершину поиска (Search Node)
        if current is None:
            break
        
        v = current.vertex  # получаем соответствующую вершину 
        ast.add_to_closed(current)  # добавили в CLOSED, так как сейчас её раскроем

        # если достаточно приблизились к финишу, то считаем, что путь найден -> досрочно завершаем поиск
        if is_goal(v):
            OPEN = ast.opened
            CLOSED = ast.expanded
            return True, current, steps, OPEN, CLOSED

        # иначе раскрываем вершину v - ищем ее соседей и пересчитываем до них расстояние
        for u in get_successors(v):
            new_node = SearchNode(u)  # создали какую-то Search Node с очередным соседом v - вершиной u
            if not ast.was_expanded(new_node):  # проверяем, что u ещё не раскрыта (проверяем с помощью окружающей её new_node, но, как уже было сказано, от Search Node в CLOSED ничего не зависит - проверка происходит на уровне вершин)
                new_node.g = current.g + compute_cost(v, u)  # теперь заполняем new_node нужной информацией: f,g,h и parent
                new_node.h = w*heuristic_func(u)
                new_node.f = new_node.g + new_node.h
                new_node.parent = current
                ast.add_to_open(new_node)

        steps += 1
    
    # если вышли из цикла, значит OPEN кончился, а путь ещё не найден -> пути просто не существует
    CLOSED = ast.expanded
    return False, None, steps, None, CLOSED
