# Методы построения кинематически-согласованной траектории перемещения мобильного агента

Данный репозиторий содержит программный код к Выпускной квалификационной работе (ВКР). Актуальный текст ВКР, а также презентацию с защиты можно найти в папке `report`. 


### Описание

Здесь представлены реализации всех алгоритмов, присутствующих в ВКР: A* для поиска на state lattice и на графе типов, генерация control set, нумерация конфигураций. Код, который работает в формате предвычислений (генерация траекторий и нумерация конфигураций) написан на языке `Python`, код для непосредственного поиска на графе (алгоритм A*) имеет две реализации: на `Python` вместе с иллюстрацией работы в `Jupyter Notebook`, а также на `C++` для проведения эффективных тестирований. Весь код подробно документирован, но является неотъемлемой частью ВКР: может ссылаться на её текст, использует её терминологию. 

Карты для тестирований и сценарии для них взяты из популярной коллекции `MovingAI`, повсеместно использующейся в области планирования маршрутов: https://movingai.com/benchmarks/grids.html. Остальные файлы (control set с примитивами, типы конфигураций) генерировались самостоятельно, код для этого представлен в данном репозитории.

### Структура проекта

```
├── Alternative solution/       # Демонстрация альтернативного решения (поиск на графе типов) в виде Jupyter Notebook      
├── Baseline solution/          # Демонстрация базового решения (поиск на state lattice) в виде Jupyter Notebook 
├── Experiments/                # Директория, отвечающая за проведение экспериментов
    ├── cpp-effective-solution/      # Код эффективной реализации базового и альтернативного решений на C++ 
├── Generating control set/     # Директория с кодом для генерации, визуализации и сохранения в файл control set 
    ├── trajectory_optimization.py   # Код для генерации короткой траектории (многомерным методом Ньютона)
    ├── create_prims_file.py         # Код для генерации txt-файла с control set
    ├── *.ipynb                      # Примеры, как можно генерировать control set
    └── *.txt                        # Результаты: 3 файла различных наборов control set
├── Numbering configurations/   # Код для нумерации конфигураций и генерации файлов с типами
    ├── numbering_configurations.py  # По данному txt-файлу с control set нумерует конфигурации и сохраняет в файл
    ├── *_control_set.txt            # Примеры control set
    └── *_types.txt                  # Результат нумерации конфигураций этих control set
└── common/                     # Директория c общими Python-файлами
    ├── KC_graphics.py               # Код, отвечающий за графическое представление результатов алгоритмов
    ├── KC_searching.py              # Код с структурами и функциями для поиска алгоритмом A* на любых графах
    └── KC_structs.py                # Общие структуры для разных алгоритмов
```

Замечание: в репозитории представлен файл `.gitattributes`, который убирает `.ipynb`-файлы из списка использованных языков, который отображается на GitHub. Так сделано потому, что эти файлы имеют огромный размер (так как в них много
иллюстраций), а потому распознаются GitHub как основной язык программирования для репозитория, что, конечно, не правда(в них только иллюстрации).


#### Использование:

Код в Python- и Jupyter Notebook- файлах использует стандартные библиотеки и легко запускается на большинстве компьютеров. Код на C++, который представлен в директории `/Experiments/cpp-effective-solution/`, снабжён `Makefile` для сборки проекта командой:

```
make test_astar
```

Эта команда создаст один исполняемый файл `test_astar`, который можно запустить через `./test_astar`. По умолчанию это начнёт процесс тестирования четырёх карт для трёх различных наборах control set (и соответствующих им типов). Тестирование каждой пары (карта, control_set) производится в отдельном процессе (созданном через `fork`, который должен работать во всех `POSIX`-системах). Таким образом, всего будет создано 12 параллельных процессов. Важно! это сильно нагружает компьютер, поэтому просто так запускать такое локально не стоит: предпочтительно запускать тестирование на отдельном сервере. Если подключение к серверу производится по `ssh`, то стоит отделить процесс тестирования от ssh-сессии (чтобы её можно было спокойно закрыть, так как тестирование будет длиться 2-3 дня), например, такой командой:
```
nohup ./test_astar > out 2>err &
```
Эта команда запустит программу `test_astar` отдельно от ssh-сессии, а её вывод и поток ошибок перенаправит в файлы `out` и `err` соответственно.

Если требуется просто запустить алгоритм на небольшом наборе тестов без параллелизма, то необходимо отредактировать файл `KC_testing.cpp`, где находится функция `main`. Также нужно не забывать редактировать файл `common.hpp`, где перечислены основные настройки. Как именно редактировать -- понятно из комментариев к коду.

